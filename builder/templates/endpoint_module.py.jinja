{% from "helpers.jinja" import safe_docstring %}

{# Generate arguments for function #}
{%- macro arguments(endpoint) %}
{# path parameters #}
{% for parameter in endpoint.path_parameters %}
{{ parameter.to_string() }},
{%- endfor -%}
{# query parameters #}
{%- for parameter in endpoint.query_parameters -%}
{{ parameter.to_string() }},
{%- endfor -%}
{# Any allowed bodies #}
{%- if endpoint.bodies | length -%}
**kwargs: Unpack[{% for body in endpoint.bodies %}{{ body.prop.get_type_string() }}{% if not loop.last %}|{% endif %}{% endfor %}]
{% endif %}
{% endmacro %}

{# Build url #}
{%- macro url(endpoint) %}
{% if endpoint.path_parameters | length == 0 %}
"{{ endpoint.path }}"
{% else %}
"{{ endpoint.path }}".format(
    {%- for parameter in endpoint.path_parameters -%}
    {{parameter.python_name}}={{parameter.python_name}}
    {%- if not loop.last -%}
    ,
    {%- endif -%}
    {%- endfor -%}
    )
{% endif %}
{%- endmacro %}

{# Prepare query params #}
{%- macro query_params(endpoint) %}
{% if endpoint.query_parameters %}
params: dict[str, Any] = {}
{% for property in endpoint.query_parameters %}
    {% set destination = property.python_name %}
    {% import "property_templates/" + property.template as prop_template %}
    {% if prop_template.transform %}
        {% set destination = "json_" + property.python_name %}
{{ prop_template.transform(property, property.python_name, destination) }}
    {% endif %}
    {%- if not property.json_is_dict %}
params["{{ property.name }}"] = {{ destination }}
    {% else %}
{{ guarded_statement(property, destination, "params.update(" + destination + ")") }}
    {% endif %}

{% endfor %}
params = {k: v for k, v in params.items() if v is not None}
{% endif %}
{% endmacro %}

{# Prepare request #}
{%- macro make_request(endpoint, follow_redirects=False) %}
{%- if endpoint.query_parameters -%}
{{ query_params(endpoint) }}
{%- endif -%}
response = self.make_request(method="{{ endpoint.method }}", url={{ url(endpoint) }},
{%- if endpoint.bodies | length -%}
json=kwargs,
{%- endif -%}
{%- if endpoint.query_parameters -%}
params=params,
{%- endif -%}
{%- if follow_redirects -%}
follow_redirects=redirect,
timeout=60 if redirect else 5,
{# TODO: probably want to allow users to choose timeout #}
{%- endif -%}
)
{% endmacro %}

{%- macro docstring_content(endpoint, return_string) %}
{% if endpoint.summary %}{{ endpoint.summary | wordwrap(100)}}

{% endif -%}
{%- if endpoint.description %}
{{ endpoint.description | wordwrap(100) }}

{% endif %}
{% if not endpoint.summary and not endpoint.description %}
{# Leave extra space so that Args or Returns isn't at the top #}

{% endif %}
Args:
    {% for param in endpoint.path_parameters %}
    {{ param.to_docstring() | wordwrap(90) | indent(8) }}
    {% endfor %}{% for param in endpoint.query_parameters %}
    {{ param.to_docstring() | wordwrap(90) | indent(8) }}
    {% endfor %}
    {% for string in endpoint.body_docstrings %}
    {{ string | wordwrap(90) | indent(8) }}
    {% endfor %}

Returns:
    {{ return_string }}
{% endmacro %}

{%- macro docstring(endpoint, return_string, is_detailed) %}
{{ safe_docstring('\n' ~ docstring_content(endpoint, return_string)) | indent(8) }}
{% endmacro %}

{% set ns = namespace(types=[]) %}

{% macro get_union_types(union_str) %}
{# Extract types from a Union[...] string #}
{% if union_str.startswith("Union[") %}
    {% set inner = union_str | replace("Union[", "") | replace("]", "") %}
    {% set raw_types = inner | split(",") %}
    {% set types = [] %}
    {% for t in raw_types %}
      {% set clean = t | replace("'", "") | trim %}
      {% set _ = types.append(clean) %}
    {% endfor %}
    {% set ns.types = types %}
{% else %}
    [type_string]
{% endif %}
{% endmacro %}
import io

from collections.abc import Callable
from typing import Any, Unpack

from satvu_api_sdk.core import SDKClient
from satvu_api_sdk.utils import disambiguate_union_response

{% for endpoint in endpoints %}
{% for relative in endpoint.relative_imports | sort %}
{{ relative }}
{% endfor %}
{% endfor %}

class {{ api_id | title }}Service(SDKClient):
    base_path = "{{ base_path }}"

    def __init__(self, get_token: Callable[[], str], env: str | None):
        super().__init__(env=env, get_token=get_token)

    {% for endpoint in endpoints %}
    {% set success_responses = endpoint.responses | selectattr("status_code.is_success") | list %}
    {% set redirect_response = endpoint.responses | selectattr("status_code.is_redirection") | list %}
    {% set return_string = endpoint.responses[0].prop.get_type_string(quoted=False) %}
    {# TODO: Update return_string to handle multiple success responses #}
    def {{ endpoint.name }}(self, {{ arguments(endpoint) }}) -> {{ return_string }}:
        {{ docstring(endpoint, return_string, is_detailed=true) }}
        {% if redirect_response | length > 0 %}
        {{ make_request(endpoint, follow_redirects=True) | indent(8) }}
        {% else %}
        {{ make_request(endpoint) | indent(8) }}
        {% endif %}

        {% if redirect_response %}
        if response.headers.get("Content-Type") == 'application/zip':
            zip_bytes = io.BytesIO(response.content)
            return zip_bytes
        {% endif %}

        {% for response in success_responses %}
        if response.status_code == {{ response.status_code }}:
            {% set response_type = response.prop.get_type_string(quoted=False) %}
            {% if response_type.startswith("Union[") %}
            # Use centrally-defined union disambiguation (handles recursive matching and discriminators)
            response_data = response.json()
            return disambiguate_union_response(response_data, {{ endpoint.response_disambiguation }})
            {% elif response_type == 'Any' %}
            return response.json()
            {% else %}
            return {{ response_type }}(**response.json())
            {% endif %}
        {% endfor %}
        return response.json()
    {% endfor %}
