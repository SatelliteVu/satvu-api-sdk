name: Release

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      api:
        description: 'Which API to rebuild (leave empty for all)'
        type: choice
        options:
          - ''
          - catalog
          - cos
          - id
          - otm
          - policy
          - reseller
          - wallet
      qa:
        description: 'Build for QA environment'
        type: boolean
        default: false
      commit_message:
        description: 'Release title (e.g., feat(catalog): add endpoint)'
        type: string
        required: false
      changelog:
        description: 'Markdown changelog body from OpenAPI diff'
        type: string
        required: false

concurrency:
  group: sdk-release-${{ inputs.qa == true && 'qa' || 'prod' }}
  cancel-in-progress: true

env:
  DAGGER_NO_NAG: "1"

jobs:
  # Check if release should be skipped for push events
  check-changes:
    name: Check for releasable changes
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check for src changes since last tag
        id: check
        run: |
          # Find the last production release tag (exclude .dev QA tags)
          LAST_TAG=$(git tag -l 'v*' --sort=-v:refname | grep -v '\.dev' | head -1)
          echo "Last tag: $LAST_TAG"

          # Get all changed files since the last tag
          CHANGED_FILES=$(git diff --name-only "$LAST_TAG" HEAD)

          # Check if any src/**/*.py files changed (excluding *_test.py)
          SHOULD_RELEASE="false"
          for file in $CHANGED_FILES; do
            if [[ "$file" == src/*.py || "$file" == src/**/*.py ]] && [[ "$file" != *_test.py ]]; then
              echo "Found releasable change: $file"
              SHOULD_RELEASE="true"
              break
            fi
          done

          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "Should release: $SHOULD_RELEASE"

  test:
    name: Test
    runs-on: ubuntu-latest-4-cores
    needs: [check-changes]
    # Run if:
    # - Push event AND changes detected
    # - workflow_dispatch event (always)
    if: |
      always() &&
      (
        (github.event_name == 'push' && needs.check-changes.outputs.should_release == 'true') ||
        github.event_name == 'workflow_dispatch'
      )
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Install uv
        uses: astral-sh/setup-uv@v7

      # Cache OpenAPI specs - ensures test uses same specs as release
      - name: Cache OpenAPI specs
        uses: actions/cache@v4
        with:
          path: .cache
          key: openapi-specs-${{ github.run_id }}
          restore-keys: |
            openapi-specs-

      # Run targeted tests when API is specified
      - name: Run targeted tests
        if: inputs.api != ''
        uses: dagger/dagger-for-github@v8.2.0
        env:
          SATVU_TRIGGERED_API: ${{ inputs.api }}
          SATVU_SPEC_ENV: ${{ inputs.qa == true && 'qa' || 'prod' }}
        with:
          call: test-api --api=${{ inputs.api }}

      # Run full tests when no API specified
      - name: Run full tests
        if: inputs.api == ''
        uses: dagger/dagger-for-github@v8.2.0
        env:
          SATVU_TRIGGERED_API: none
          SATVU_SPEC_ENV: ${{ inputs.qa == true && 'qa' || 'prod' }}
        with:
          call: test

  release:
    name: Release
    runs-on: ubuntu-latest
    needs: [check-changes, test]
    # Run if:
    # - Push event AND changes detected
    # - workflow_dispatch event (always)
    if: |
      always() &&
      needs.test.result == 'success' &&
      (
        (github.event_name == 'push' && needs.check-changes.outputs.should_release == 'true') ||
        github.event_name == 'workflow_dispatch'
      )
    environment: ${{ inputs.qa == true && 'qa' || 'pypi' }}
    # Permissions for PyPI trusted publishing (OIDC) and creating releases
    permissions:
      id-token: write
      contents: write
    steps:
      - name: Generate app token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.PUBLIC_RELEASE_MANAGER_ID }}
          private-key: ${{ secrets.PUBLIC_RELEASE_MANAGER_SECRET }}

      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}

      - name: Show pending release
        run: |
          echo "## ðŸ“¦ Pending Release" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          # Find the last production release tag (exclude .dev QA tags)
          LAST_TAG=$(git tag -l 'v*' --sort=-v:refname | grep -v '\.dev' | head -1)
          echo "### Commits since \`$LAST_TAG\`:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          git log ${LAST_TAG}..HEAD --oneline >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 'lts/*'

      - name: Install semantic-release
        run: npm install -g semantic-release @semantic-release/changelog @semantic-release/git @semantic-release/exec

      - name: Install uv
        uses: astral-sh/setup-uv@v7

      # Cache OpenAPI specs between runs
      # - Restores most recent cache (restore-keys fallback)
      # - Saves with unique key per run (captures any freshly fetched specs)
      # - SATVU_TRIGGERED_API controls which API fetches fresh vs uses cache
      - name: Cache OpenAPI specs
        uses: actions/cache@v4
        with:
          path: .cache
          key: openapi-specs-${{ github.run_id }}
          restore-keys: |
            openapi-specs-

      # Install Dagger CLI (needed by semantic-release prepareCmd)
      - name: Install Dagger CLI
        if: github.event_name == 'push'
        run: curl -fsSL https://dl.dagger.io/dagger/install.sh | BIN_DIR=$HOME/.local/bin sh

      # ===========================================
      # PATH 1: Push events (PR merges) - use semantic-release
      # ===========================================

      # Production release via semantic-release (push events only)
      # semantic-release handles: version bump, CHANGELOG, git tag, GitHub release
      - name: Run semantic-release
        if: github.event_name == 'push'
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          SATVU_TRIGGERED_API: none
          SATVU_SPEC_ENV: prod
        run: semantic-release

      # Publish to PyPI (push events - semantic-release creates artifacts)
      - name: Publish to PyPI (push)
        if: github.event_name == 'push' && hashFiles('dist/*') != ''
        uses: pypa/gh-action-pypi-publish@release/v1

      # ===========================================
      # PATH 2: workflow_dispatch - timestamp versioning
      # ===========================================

      # Calculate timestamp version for API triggers
      - name: Calculate timestamp version
        if: github.event_name == 'workflow_dispatch'
        id: version
        run: |
          # Get base semver from pyproject.toml
          BASE_VERSION=$(grep -Po '^version = "\K[^"]*' pyproject.toml)
          echo "Base version: $BASE_VERSION"

          # Calculate timestamp: YYYYMMDD.HHMM
          TIMESTAMP=$(date -u +%Y%m%d.%H%M)
          echo "Timestamp: $TIMESTAMP"

          # Build full version
          if [ "${{ inputs.qa }}" == "true" ]; then
            FULL_VERSION="${BASE_VERSION}.${TIMESTAMP}rc0"
          else
            FULL_VERSION="${BASE_VERSION}.${TIMESTAMP}"
          fi

          echo "Full version: $FULL_VERSION"
          echo "full_version=$FULL_VERSION" >> $GITHUB_OUTPUT
          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT

      # Build with calculated version (workflow_dispatch)
      - name: Build release
        if: github.event_name == 'workflow_dispatch'
        uses: dagger/dagger-for-github@v8.2.0
        env:
          SATVU_TRIGGERED_API: ${{ inputs.api || 'none' }}
          SATVU_SPEC_ENV: ${{ inputs.qa == true && 'qa' || 'prod' }}
        with:
          call: build-release --is-qa=${{ inputs.qa == true }} --version=${{ steps.version.outputs.full_version }} export --path=./dist --wipe

      # Publish to PyPI (workflow_dispatch prod)
      - name: Publish to PyPI (API trigger)
        if: github.event_name == 'workflow_dispatch' && inputs.qa != true
        uses: pypa/gh-action-pypi-publish@release/v1

      # Publish to CodeArtifact (QA only)
      - name: Publish to CodeArtifact
        if: inputs.qa == true
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          # Get CodeArtifact auth token
          CODEARTIFACT_AUTH_TOKEN=$(aws codeartifact get-authorization-token \
            --domain ${{ secrets.AWS_CODEARTIFACT_DOMAIN }} \
            --domain-owner ${{ secrets.AWS_ACCOUNT_ID }} \
            --query authorizationToken \
            --output text)

          # Get repository endpoint
          REPO_URL=$(aws codeartifact get-repository-endpoint \
            --domain ${{ secrets.AWS_CODEARTIFACT_DOMAIN }} \
            --domain-owner ${{ secrets.AWS_ACCOUNT_ID }} \
            --repository ${{ secrets.AWS_CODEARTIFACT_REPOSITORY }} \
            --format pypi \
            --query repositoryEndpoint \
            --output text)

          # Upload with uv
          uv publish --publish-url "${REPO_URL}" --username aws --password "${CODEARTIFACT_AUTH_TOKEN}"

      # Update CHANGELOG for API triggers (prod only)
      - name: Update CHANGELOG
        if: github.event_name == 'workflow_dispatch' && inputs.qa != true && inputs.changelog != ''
        env:
          CHANGELOG: ${{ inputs.changelog }}
          COMMIT_MESSAGE: ${{ inputs.commit_message }}
          API_NAME: ${{ inputs.api }}
        run: |
          VERSION="${{ steps.version.outputs.full_version }}"
          DATE=$(date -u +%Y-%m-%d)

          # Use commit_message as header if provided, otherwise default to API Updates
          HEADER="${COMMIT_MESSAGE:-API Updates (${API_NAME})}"

          # Create new changelog entry
          NEW_ENTRY="## [$VERSION] - $DATE

          ### ${HEADER}

          $CHANGELOG
          "

          # Prepend to CHANGELOG.md (after the title line)
          if [ -f CHANGELOG.md ]; then
            # Insert after first line (title)
            head -1 CHANGELOG.md > CHANGELOG.tmp
            echo "" >> CHANGELOG.tmp
            echo "$NEW_ENTRY" >> CHANGELOG.tmp
            tail -n +2 CHANGELOG.md >> CHANGELOG.tmp
            mv CHANGELOG.tmp CHANGELOG.md
          else
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "$NEW_ENTRY" >> CHANGELOG.md
          fi

      # Commit CHANGELOG update
      - name: Commit CHANGELOG
        if: github.event_name == 'workflow_dispatch' && inputs.qa != true && inputs.changelog != ''
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add CHANGELOG.md
          git commit -m "docs(changelog): ${{ steps.version.outputs.full_version }} [skip ci]" || echo "No changes to commit"
          git push

      # Create git tag for API triggers (prod only)
      - name: Create git tag
        if: github.event_name == 'workflow_dispatch' && inputs.qa != true
        run: |
          VERSION="${{ steps.version.outputs.full_version }}"
          git tag -a "v${VERSION}" -m "Release v${VERSION}"
          git push origin "v${VERSION}"

      # Create GitHub release for API triggers (prod only)
      - name: Create GitHub release
        if: github.event_name == 'workflow_dispatch' && inputs.qa != true
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          RELEASE_TITLE: ${{ inputs.commit_message }}
          API_NAME: ${{ inputs.api }}
          CHANGELOG_BODY: ${{ inputs.changelog }}
        run: |
          VERSION="${{ steps.version.outputs.full_version }}"
          TITLE="${RELEASE_TITLE:-${API_NAME} API update}"

          if [ -n "$CHANGELOG_BODY" ]; then
            gh release create "v${VERSION}" \
              --title "${TITLE}" \
              --notes "$CHANGELOG_BODY" \
              dist/*
          else
            gh release create "v${VERSION}" \
              --title "${TITLE}" \
              --generate-notes \
              dist/*
          fi
