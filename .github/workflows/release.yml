name: Release

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      api:
        description: 'Which API to rebuild (leave empty for all)'
        type: choice
        options:
          - ''
          - catalog
          - cos
          - id
          - otm
          - policy
          - reseller
          - wallet
      qa:
        description: 'Build for QA environment'
        type: boolean
        default: false
      commit_message:
        description: 'Conventional commit message (e.g., feat(catalog): add endpoint)'
        type: string
        required: false
  workflow_call:
    inputs:
      api:
        description: 'Which API schema changed'
        type: string
        required: true
      qa:
        description: 'Build for QA environment'
        type: boolean
        default: false
      commit_message:
        description: 'Conventional commit subject (e.g., feat(wallet): add endpoint)'
        type: string
        required: true
      changelog:
        description: 'Markdown changelog body from OpenAPI diff'
        type: string
        required: false

concurrency:
  group: sdk-release
  cancel-in-progress: false

env:
  DAGGER_NO_NAG: "1"

jobs:
  # Check if release should be skipped for push events
  check-changes:
    name: Check for releasable changes
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check for src changes
        id: check
        run: |
          # Get all changed files in this push
          CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})

          # Check if any src/**/*.py files changed (excluding *_test.py)
          SHOULD_RELEASE="false"
          for file in $CHANGED_FILES; do
            if [[ "$file" == src/*.py || "$file" == src/**/*.py ]] && [[ "$file" != *_test.py ]]; then
              echo "Found releasable change: $file"
              SHOULD_RELEASE="true"
              break
            fi
          done

          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "Should release: $SHOULD_RELEASE"

  test:
    name: Test
    runs-on: ubuntu-latest
    needs: [check-changes]
    # Run if:
    # - Push event AND changes detected
    # - workflow_call event (always)
    # - workflow_dispatch event (always)
    if: |
      always() &&
      (
        (github.event_name == 'push' && needs.check-changes.outputs.should_release == 'true') ||
        github.event_name == 'workflow_call' ||
        github.event_name == 'workflow_dispatch'
      )
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Install uv
        uses: astral-sh/setup-uv@v7

      - name: Install Dagger
        uses: dagger/dagger-for-github@v8.2.0
        with:
          install-only: true

      # Cache OpenAPI specs - ensures test uses same specs as release
      - name: Cache OpenAPI specs
        uses: actions/cache@v4
        with:
          path: .cache
          key: openapi-specs-${{ github.run_id }}
          restore-keys: |
            openapi-specs-

      # Run targeted tests when API is specified
      - name: Run targeted tests
        if: inputs.api != ''
        env:
          SATVU_TRIGGERED_API: ${{ inputs.api }}
          SATVU_SPEC_ENV: ${{ inputs.qa == true && 'qa' || 'prod' }}
        run: |
          dagger call test-api --api=${{ inputs.api }}

      # Run full tests when no API specified
      - name: Run full tests
        if: inputs.api == ''
        env:
          SATVU_TRIGGERED_API: none
          SATVU_SPEC_ENV: ${{ inputs.qa == true && 'qa' || 'prod' }}
        run: |
          dagger call test

  release:
    name: Release
    runs-on: ubuntu-latest
    needs: [check-changes, test]
    # Run if:
    # - Push event AND changes detected
    # - workflow_call event (always)
    # - workflow_dispatch event (always)
    if: |
      always() &&
      needs.test.result == 'success' &&
      (
        (github.event_name == 'push' && needs.check-changes.outputs.should_release == 'true') ||
        github.event_name == 'workflow_call' ||
        github.event_name == 'workflow_dispatch'
      )
    environment: ${{ inputs.qa == true && 'qa' || 'pypi' }}
    # Permissions for PyPI trusted publishing (OIDC) and creating releases
    permissions:
      id-token: write
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Show pending release
        run: |
          echo "## ðŸ“¦ Pending Release" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -n "$LAST_TAG" ]; then
            echo "### Commits since \`$LAST_TAG\`:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            git log ${LAST_TAG}..HEAD --oneline >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          else
            echo "### All commits (no previous release):" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            git log --oneline -20 >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 'lts/*'

      - name: Install semantic-release
        run: npm install -g semantic-release @semantic-release/changelog @semantic-release/git @semantic-release/exec

      - name: Install uv
        uses: astral-sh/setup-uv@v7

      - name: Install Dagger
        uses: dagger/dagger-for-github@v8.2.0
        with:
          install-only: true

      # Cache OpenAPI specs between runs
      # - Restores most recent cache (restore-keys fallback)
      # - Saves with unique key per run (captures any freshly fetched specs)
      # - SATVU_TRIGGERED_API controls which API fetches fresh vs uses cache
      - name: Cache OpenAPI specs
        uses: actions/cache@v4
        with:
          path: .cache
          key: openapi-specs-${{ github.run_id }}
          restore-keys: |
            openapi-specs-

      # For workflow_call: create commit with subject + changelog body
      - name: Create spec update commit
        if: github.event_name == 'workflow_call' && inputs.qa == false
        env:
          CHANGELOG: ${{ inputs.changelog }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Build commit: subject [skip ci] + optional multiline changelog body
          if [ -n "$CHANGELOG" ]; then
            git commit --allow-empty -m "${{ inputs.commit_message }} [skip ci]" -m "$CHANGELOG"
          else
            git commit --allow-empty -m "${{ inputs.commit_message }} [skip ci]"
          fi
          git push

      # For workflow_dispatch with commit_message: commit it directly
      - name: Create manual update commit
        if: github.event_name == 'workflow_dispatch' && inputs.commit_message != '' && inputs.qa == false
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git commit --allow-empty -m "${{ inputs.commit_message }} [skip ci]"
          git push

      # Production release via semantic-release
      - name: Run semantic-release
        if: inputs.qa != true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SATVU_TRIGGERED_API: ${{ inputs.api || 'none' }}
          SATVU_SPEC_ENV: prod
        run: semantic-release

      # Publish to PyPI using trusted publishing (OIDC)
      - name: Publish to PyPI
        if: inputs.qa != true
        uses: pypa/gh-action-pypi-publish@release/v1

      # QA build (skip semantic-release)
      - name: Build QA release
        if: inputs.qa == true
        env:
          SATVU_TRIGGERED_API: ${{ inputs.api || 'none' }}
          SATVU_SPEC_ENV: qa
        run: |
          dagger call build-release --is-qa=true export --path=./dist --wipe

      - name: Generate QA version
        if: inputs.qa == true
        id: qa_version
        run: |
          # Get current version and bump patch for QA
          CURRENT_VERSION=$(grep -Po '(?<=version = ")[^"]*' pyproject.toml)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          NEXT_PATCH=$((PATCH + 1))
          DATE=$(date +%y%m%d)
          QA_VERSION="${MAJOR}.${MINOR}.${NEXT_PATCH}.dev${DATE}${{ github.run_number }}"
          echo "version=${QA_VERSION}" >> $GITHUB_OUTPUT
          echo "QA Version: ${QA_VERSION}"

      - name: Publish to CodeArtifact
        if: inputs.qa == true
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          # Get CodeArtifact auth token
          CODEARTIFACT_AUTH_TOKEN=$(aws codeartifact get-authorization-token \
            --domain ${{ secrets.AWS_CODEARTIFACT_DOMAIN }} \
            --domain-owner ${{ secrets.AWS_ACCOUNT_ID }} \
            --query authorizationToken \
            --output text)

          # Get repository endpoint
          REPO_URL=$(aws codeartifact get-repository-endpoint \
            --domain ${{ secrets.AWS_CODEARTIFACT_DOMAIN }} \
            --domain-owner ${{ secrets.AWS_ACCOUNT_ID }} \
            --repository ${{ secrets.AWS_CODEARTIFACT_REPOSITORY }} \
            --format pypi \
            --query repositoryEndpoint \
            --output text)

          # Upload with uv
          uv publish --publish-url "${REPO_URL}" --username aws --password "${CODEARTIFACT_AUTH_TOKEN}"

      - name: Create QA tag
        if: inputs.qa == true
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag "v${{ steps.qa_version.outputs.version }}"
          git push origin "v${{ steps.qa_version.outputs.version }}"
